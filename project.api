# tinyexpr.h
!main.cpp graphics.h keys_n_colors.h stdio.h string.h tinyexpr.h #<#>
!tinyexpr.c ctype.h limits.h math.h stdio.h stdlib.h string.h tinyexpr.h #<#>
 struct@state _type_ #<tinyexpr.c>
 struct@te_expr _type_ #<tinyexpr.h>
 struct@te_variable _type_ #<tinyexpr.h>
ARITY(TYPE) #<tinyexpr.c>
CHECK_NULL(ptr, ...) #<tinyexpr.c>
IS_CLOSURE(TYPE) #<tinyexpr.c>
IS_FUNCTION(TYPE) #<tinyexpr.c>
IS_PURE(TYPE) #<tinyexpr.c>
M(e) #<tinyexpr.c>
MAX_EQUATIONS #<main.cpp>
MAX_EQUATION_LENGTH #<main.cpp>
NEW_EXPR(type, ...) #<tinyexpr.c>
TE_FUN(...) #<tinyexpr.c>
TYPE_MASK(TYPE) #<tinyexpr.c>
X1 : const char* #<main.cpp>
X2 : const char* #<main.cpp>
Y1 : const char* #<main.cpp>
Y2 : const char* #<main.cpp>
add(double a, double b) -> double #<tinyexpr.c>
ax : int #<main.cpp>
background() -> void #<main.cpp>
base(state* s) -> te_expr* #<tinyexpr.c>
buffer1 : doublex_max=30;double y_min=-30, y_max=30;char[] #<main.cpp>
buffer2 : double[] #<main.cpp>
buffer3 : double[] #<main.cpp>
buffer4 : double[] #<main.cpp>
bx : int #<main.cpp>
clear_character(int x, int y) -> void #<main.cpp>
comma(double a, double b) -> double #<tinyexpr.c>
cy : int #<main.cpp>
divide(double a, double b) -> double #<tinyexpr.c>
draw(double i, double v, const char* axis) -> void #<main.cpp>
draw_cursor(int x, int y, int c) -> void #<main.cpp>
drawing_graph(int equation_index) -> void #<main.cpp>
e(void) -> double #<tinyexpr.c>
entering(int x, int y, char* equations, int MAX_LENGTH, const char* dop, int type, int nomer) -> void #<main.cpp>
entering_equations(int x, int y) -> void #<main.cpp>
entering_ranges(int x, int y) -> bool #<main.cpp>
enum :  #<tinyexpr.h>
eqSet : Equation #<main.cpp>
expr(state* s) -> te_expr* #<tinyexpr.c>
f_color : inttext_y=0;int[] #<main.cpp>
fac(double a) -> double #<tinyexpr.c>
factor(state* s) -> te_expr* #<tinyexpr.c>
find_builtin(const char* name, int len) -> const te_variable* #<tinyexpr.c>
find_lookup(const state* s, const char* name, int len) -> const te_variable* #<tinyexpr.c>
functions : const te_variable[] #<tinyexpr.c>
list(state* s) -> te_expr* #<tinyexpr.c>
main() -> int #<main.cpp>
mul(double a, double b) -> double #<tinyexpr.c>
ncr(double n, double r) -> double #<tinyexpr.c>
negate(double a) -> double #<tinyexpr.c>
new_expr(const int type, const te_expr* parameters[]) -> te_expr* #<tinyexpr.c>
next_token(state* s) -> void #<tinyexpr.c>
npr(double n, double r) -> double #<tinyexpr.c>
optimize(te_expr* n) -> void #<tinyexpr.c>
pi(void) -> double #<tinyexpr.c>
pn(const te_expr* n, int depth) -> void #<tinyexpr.c>
power(state* s) -> te_expr* #<tinyexpr.c>
recx : int[] #<main.cpp>
redrawing_area() -> void #<main.cpp>
selectstep(double dmin, double dmax) -> double #<main.cpp>
state _type_ #<tinyexpr.c>
sub(double a, double b) -> double #<tinyexpr.c>
te_compile(const char* expression, const te_variable* variables, int var_count, int* error) -> te_expr* #<tinyexpr.h>
te_eval(const te_expr* n) -> double #<tinyexpr.h>
te_expr _type_ #<tinyexpr.h>
te_free(te_expr* n) -> void #<tinyexpr.h>
te_free_parameters(te_expr* n) -> void #<tinyexpr.c>
te_fun2 _type_ #<tinyexpr.c>
te_interp(const char* expression, int* error) -> double #<tinyexpr.h>
te_print(const te_expr* n) -> void #<tinyexpr.h>
te_variable _type_ #<tinyexpr.h>
term(state* s) -> te_expr* #<tinyexpr.c>
text_x : int #<main.cpp>
wx : int #<main.cpp>
x0 : intwy=600;int Lx=wx/3+wy/20, Ly=wy/20;int Nx=wx-wy/20, Ny=wy-(wy/10+wy/20);int #<main.cpp>
x_min : double #<main.cpp>
y0 : int #<main.cpp>
	state::start : const char* #<tinyexpr.c>
	state::next : const char* #<tinyexpr.c>
	state::type : int #<tinyexpr.c>
	state::union :  #<tinyexpr.c>
	state::context : void* #<tinyexpr.c>
	state::lookup : const te_variable* #<tinyexpr.c>
	state::lookup_len : int #<tinyexpr.c>
	te_expr::type : int #<tinyexpr.h>
	te_expr::union :  #<tinyexpr.h>
	te_expr::parameters : void*[] #<tinyexpr.h>
	te_variable::name : const char* #<tinyexpr.h>
	te_variable::address : const void* #<tinyexpr.h>
	te_variable::type : int #<tinyexpr.h>
	te_variable::context : void* #<tinyexpr.h>

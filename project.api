# tinyexpr.h
!tinyexpr.c ctype.h limits.h math.h stdio.h stdlib.h string.h tinyexpr.h #<#>
 struct@state _type_ #<tinyexpr.c>
 struct@te_expr _type_ #<tinyexpr.h>
 struct@te_variable _type_ #<tinyexpr.h>
ARITY(TYPE) #<tinyexpr.c>
CHECK_NULL(ptr, ...) #<tinyexpr.c>
IS_CLOSURE(TYPE) #<tinyexpr.c>
IS_FUNCTION(TYPE) #<tinyexpr.c>
IS_PURE(TYPE) #<tinyexpr.c>
M(e) #<tinyexpr.c>
NEW_EXPR(type, ...) #<tinyexpr.c>
TE_FUN(...) #<tinyexpr.c>
TYPE_MASK(TYPE) #<tinyexpr.c>
add(double a, double b) -> double #<tinyexpr.c>
base(state* s) -> te_expr* #<tinyexpr.c>
comma(double a, double b) -> double #<tinyexpr.c>
divide(double a, double b) -> double #<tinyexpr.c>
e(void) -> double #<tinyexpr.c>
enum :  #<tinyexpr.h>
expr(state* s) -> te_expr* #<tinyexpr.c>
fac(double a) -> double #<tinyexpr.c>
factor(state* s) -> te_expr* #<tinyexpr.c>
find_builtin(const char* name, int len) -> const te_variable* #<tinyexpr.c>
find_lookup(const state* s, const char* name, int len) -> const te_variable* #<tinyexpr.c>
functions : const te_variable[] #<tinyexpr.c>
list(state* s) -> te_expr* #<tinyexpr.c>
mul(double a, double b) -> double #<tinyexpr.c>
ncr(double n, double r) -> double #<tinyexpr.c>
negate(double a) -> double #<tinyexpr.c>
new_expr(const int type, const te_expr* parameters[]) -> te_expr* #<tinyexpr.c>
next_token(state* s) -> void #<tinyexpr.c>
npr(double n, double r) -> double #<tinyexpr.c>
optimize(te_expr* n) -> void #<tinyexpr.c>
pi(void) -> double #<tinyexpr.c>
pn(const te_expr* n, int depth) -> void #<tinyexpr.c>
power(state* s) -> te_expr* #<tinyexpr.c>
state _type_ #<tinyexpr.c>
sub(double a, double b) -> double #<tinyexpr.c>
te_compile(const char* expression, const te_variable* variables, int var_count, int* error) -> te_expr* #<tinyexpr.h>
te_eval(const te_expr* n) -> double #<tinyexpr.h>
te_expr _type_ #<tinyexpr.h>
te_free(te_expr* n) -> void #<tinyexpr.h>
te_free_parameters(te_expr* n) -> void #<tinyexpr.c>
te_fun2 _type_ #<tinyexpr.c>
te_interp(const char* expression, int* error) -> double #<tinyexpr.h>
te_print(const te_expr* n) -> void #<tinyexpr.h>
te_variable _type_ #<tinyexpr.h>
term(state* s) -> te_expr* #<tinyexpr.c>
	state::start : const char* #<tinyexpr.c>
	state::next : const char* #<tinyexpr.c>
	state::type : int #<tinyexpr.c>
	state::union :  #<tinyexpr.c>
	state::context : void* #<tinyexpr.c>
	state::lookup : const te_variable* #<tinyexpr.c>
	state::lookup_len : int #<tinyexpr.c>
	te_expr::type : int #<tinyexpr.h>
	te_expr::union :  #<tinyexpr.h>
	te_expr::parameters : void*[] #<tinyexpr.h>
	te_variable::name : const char* #<tinyexpr.h>
	te_variable::address : const void* #<tinyexpr.h>
	te_variable::type : int #<tinyexpr.h>
	te_variable::context : void* #<tinyexpr.h>
